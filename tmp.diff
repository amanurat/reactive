diff --git a/reactive-web-lift/src/main/scala/reactive/web/lift/AppendToRender.scala b/reactive-web-lift/src/main/scala/reactive/web/lift/AppendToRender.scala
index 1f031ea..a43de49 100644
--- a/reactive-web-lift/src/main/scala/reactive/web/lift/AppendToRender.scala
+++ b/reactive-web-lift/src/main/scala/reactive/web/lift/AppendToRender.scala
@@ -51,7 +51,7 @@ class RenderTransport extends AccumulatingTransport {
       pc unlinkTransport this
       removeTransportType(pc)
     }
-    val include = <script type="text/javascript" src="/classpath/reactive-web.js"/>
+    val include = <script type="text/javascript" src={ S.contextPath + "/classpath/reactive-web.js" }/>
     val js =
       <script type="text/javascript">
         { Unparsed("// <![CDATA[\n" + renderData + "// ]]>") }
diff --git a/reactive-web-lift/src/main/scala/reactive/web/lift/SimpleAjaxTransportType.scala b/reactive-web-lift/src/main/scala/reactive/web/lift/SimpleAjaxTransportType.scala
index 3797335..c682742 100644
--- a/reactive-web-lift/src/main/scala/reactive/web/lift/SimpleAjaxTransportType.scala
+++ b/reactive-web-lift/src/main/scala/reactive/web/lift/SimpleAjaxTransportType.scala
@@ -5,6 +5,7 @@ package lift
 import net.liftweb.http.{ JavaScriptResponse, LiftRules, OkResponse, PostRequest, Req }
 import net.liftweb.http.js.JsCmds
 import net.liftweb.common.Full
+import net.liftweb.http.S
 
 /**
  * This is the companion module for [[SimpleAjaxTransportType]],
@@ -94,11 +95,11 @@ class SimpleAjaxTransportType(page: Page) extends AjaxTransportType {
         this.heartBeatTimeout = window.setTimeout(function() {{ reactive.doHeartBeat() }}, { heartbeatInterval });
       }};
       reactive.doHeartBeat = function() {{
-        this.ajaxImpl("/__reactive-web-ajax/heartbeat", JSON.stringify(this.pageIds));
+        this.ajaxImpl("{ S.contextPath }/__reactive-web-ajax/heartbeat", JSON.stringify(this.pageIds));
         this.resetHeartBeat();
       }};
       reactive.sendAjax['{ page.id }'] = function(jsonStr) {{
-        reactive.ajaxImpl("/__reactive-web-ajax/{ page.id }", jsonStr);
+        reactive.ajaxImpl("{ S.contextPath }/__reactive-web-ajax/{ page.id }", jsonStr);
         reactive.resetHeartBeat();
       }};
       reactive.resetHeartBeat();
diff --git a/reactive-web/src/main/scala/reactive/web/widgets/TableEditor.scala b/reactive-web/src/main/scala/reactive/web/widgets/TableEditor.scala
index e4790d3..d8bf776 100644
--- a/reactive-web/src/main/scala/reactive/web/widgets/TableEditor.scala
+++ b/reactive-web/src/main/scala/reactive/web/widgets/TableEditor.scala
@@ -3,14 +3,13 @@ package web
 package widgets
 
 import scala.xml.NodeSeq
-
-import net.liftweb.common.Failure
 import net.liftweb.util.Helpers._
 import net.liftweb.util._
-
 import reactive._
 import reactive.web._
 import reactive.web.javascript._
+import scala.util.Try
+import scala.util.Failure
 
 /**
  * Renders a table editor
@@ -58,13 +57,21 @@ trait TableEditor[A] extends TableView[A] {
    * editor turns that into a NodeSeq=>NodeSeq
    */
   class EditableCol[T](val selector: String, val get: A => T, val set: T => A => A, editor: T => Editor[T])(implicit observing: Observing) extends Col {
-    import scala.collection.mutable.Map
-    val validities = Map.empty[RowType, Signal[Validity[T, NodeSeq]]]
-    def validity(row: RowType): Signal[Validity[T, NodeSeq]] = validities getOrElseUpdate (row, renderer(row).value)
+    private def rowMap[TT] = new AtomicRef(Vector.empty[(RowType, TT)])
+    private def getOrElseUpdate[TT](map: AtomicRef[Vector[(RowType, TT)]])(row: RowType, makeNew: => TT): TT = map.run { xs =>
+      xs.find(_._1 eq row) match {
+        case Some((_, x)) => (xs, x)
+        case None =>
+          val x = makeNew
+          (xs :+ (row, x), x)
+      }
+    }
+    val validities = rowMap[Signal[Validity[T, NodeSeq]]]
+    def validity(row: RowType): Signal[Validity[T, NodeSeq]] = getOrElseUpdate(validities)(row, renderer(row).value)
 
-    val editors = Map.empty[A, Editor[T]]
+    val editors = rowMap[Editor[T]]
     val renderer = { row: RowType =>
-      editors.getOrElseUpdate(row.item, editor(get(row.item)))
+      getOrElseUpdate(editors)(row, editor(get(row.item)))
     }
 
     override def render(row: RowType)(implicit page: Page) = {
@@ -104,10 +111,9 @@ trait TableEditor[A] extends TableView[A] {
 
     lazy val modifieds = cols.map {
       case c: EditableCol[_] =>
-        actions map (_ exists {
-          case Update(i, col, v) if c == col && i == item && v != c.get(item) => true
-          case _ => false
-        })
+        val v = c.validity(this)
+        val initial = v.now
+        v.map(_ != initial)
       case _ => Val(false)
     }
 
@@ -134,17 +140,25 @@ trait TableEditor[A] extends TableView[A] {
           before ++ at.drop(1)
         case _ => xs //TODO apply updates that don't come from UI
       }
-      val current = actions.now.foldLeft(is)(applyAction(_)(_))
+      println("rows running flatMap function")
+      println(s"Applying actions ${ actions.now } to $is")
+      val current = actions.now.reverse.foldLeft(is)(applyAction(_)(_))
+      println("current = " + current)
       SeqSignal(actions).deltas.map(d => SeqDelta.flatten(d :: Nil)).foldLeft(current){
         case (xs0, ds) =>
-          ds.sortBy{
+          println(s"rows folding, xs0 = $xs0, ds = $ds")
+          val sorted = ds.sortBy{
             case Remove(_, Insert(_)) => Int.MaxValue
             case _                    => 0
-          }.foldLeft(xs0) {
+          }
+          println(s"sorted = $sorted")
+          val folded = sorted.foldLeft(xs0) {
             case (xs, Include(_, edit))              => applyAction(xs)(edit)
             case (xs, Remove(_, edit))               => applyAction(xs)(edit.inverse)
             case (xs, reactive.Update(_, old, edit)) => applyAction(applyAction(xs)(old.inverse))(edit)
           }
+          println(s"folded = $folded")
+          folded
       }.hold(current)
     },
     { (a: Seq[RowType], b: Seq[RowType]) => LCS.lcsdiff[RowType, RowType](a, b, _.item == _.item) }
@@ -162,8 +176,8 @@ trait TableEditor[A] extends TableView[A] {
   })
   edits foreach { e => println("Edit: "+e) }
   actions <<: (edits.map(Left(_)) | refreshes.map(Right(_))).foldLeft(actions.now){
-    case (as, Left(e)) => e :: as
-    case _             => Nil
+    case (as, Left(e))  => e :: as
+    case (_, Right(())) => Nil
   }
   redoActions <<: (edits | refreshes).map(_ => List.empty[Edit])
 
@@ -215,19 +229,26 @@ trait TableEditor[A] extends TableView[A] {
       } &
       ".save" #> onServer[Click]{ _ => //TODO use nonblocking
         def doSave {
-          tryo {
+          Try {
+            println("actions.now: "+actions.now)
+            println("rows.now: " + rows.now)
+            save(actions.now.reverse)
             println("actions.now: "+actions.now)
-            save(actions.now)
+            println("rows.now: " + rows.now)
+            println("BEGIN REFRESH")
             refreshes fire ()
+            println("END REFRESH")
+            println("actions.now: "+actions.now)
+            println("rows.now: " + rows.now)
           } match {
-            case Failure(msg, _, _) =>
-              messages += "Save failed: "+msg
+            case Failure(e) =>
+              messages += "Save failed: "+e.getMessage
             case _ =>
               messages += "Saved successfully!"
           }
         }
         val (warnings, errors) = cols.collect {
-          case c: EditableCol[_] => c.validities.values.map(_.now)
+          case c: EditableCol[_] => c.validities.get.map(_._2.now)
         }.flatten.foldLeft((List[Warning[_, NodeSeq]](), List[Invalid[NodeSeq]]())){
           case ((ws, is), v: Valid[_])      => (ws, is)
           case ((ws, is), w: Warning[_, _]) => (w :: ws, is)
@@ -240,7 +261,7 @@ trait TableEditor[A] extends TableView[A] {
             <xml:group>
               <p>
                 Some values have warnings.
-              Are you sure you want to save anyway?
+                Are you sure you want to save anyway?
               </p>
               <p><button class="btn btn-danger" onclick={ onServer[Click]{ _ => messages -= msg; doSave }.js }>Yes</button></p>
             </xml:group>
